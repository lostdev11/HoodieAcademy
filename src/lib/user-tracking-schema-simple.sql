-- Simplified User Tracking Schema for Hoodie Academy
-- Run this in your Supabase SQL Editor step by step

-- =====================================================
-- STEP 1: Create the enum type
-- =====================================================
DO $$ BEGIN
    CREATE TYPE public.event_kind AS ENUM (
      'wallet_connect',
      'wallet_disconnect',
      'page_view',
      'course_start',
      'course_complete',
      'lesson_start',
      'lesson_complete',
      'exam_started',
      'exam_submitted',
      'exam_approved',
      'exam_rejected',
      'placement_started',
      'placement_completed',
      'custom'
    );
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- =====================================================
-- STEP 2: Create the profiles table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  handle TEXT UNIQUE,
  display_name TEXT,
  avatar_url TEXT,
  primary_wallet TEXT,
  last_active_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS profiles_primary_wallet_idx ON public.profiles(primary_wallet);
CREATE INDEX IF NOT EXISTS profiles_last_active_idx ON public.profiles(last_active_at);

-- =====================================================
-- STEP 3: Create the wallets table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.wallets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  address TEXT NOT NULL,
  label TEXT,
  is_primary BOOLEAN NOT NULL DEFAULT false,
  connected_first_at TIMESTAMPTZ,
  connected_last_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX IF NOT EXISTS wallets_user_address_uniq ON public.wallets(user_id, address);
CREATE INDEX IF NOT EXISTS wallets_primary_idx ON public.wallets(is_primary);
CREATE INDEX IF NOT EXISTS wallets_address_idx ON public.wallets(address);

-- =====================================================
-- STEP 4: Create the sessions table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  wallet_address TEXT,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_heartbeat_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  user_agent TEXT,
  ip TEXT,
  is_active BOOLEAN DEFAULT true
);

CREATE INDEX IF NOT EXISTS sessions_user_idx ON public.sessions(user_id);
CREATE INDEX IF NOT EXISTS sessions_heartbeat_idx ON public.sessions(last_heartbeat_at);
CREATE INDEX IF NOT EXISTS sessions_active_idx ON public.sessions(is_active);

-- =====================================================
-- STEP 5: Create the event_log table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.event_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL,
  session_id UUID,
  wallet_address TEXT,
  kind public.event_kind NOT NULL,
  path TEXT,
  referrer TEXT,
  course_id TEXT,
  lesson_id TEXT,
  exam_id TEXT,
  payload JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS event_log_user_time_idx ON public.event_log(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS event_log_kind_time_idx ON public.event_log(kind, created_at DESC);
CREATE INDEX IF NOT EXISTS event_log_path_idx ON public.event_log(path);
CREATE INDEX IF NOT EXISTS event_log_session_idx ON public.event_log(session_id);
CREATE INDEX IF NOT EXISTS event_log_wallet_idx ON public.event_log(wallet_address);

-- =====================================================
-- STEP 6: Create the course_progress table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.course_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  course_id TEXT NOT NULL,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  last_event_at TIMESTAMPTZ,
  progress_percent NUMERIC(5,2) NOT NULL DEFAULT 0,
  UNIQUE (user_id, course_id)
);

CREATE INDEX IF NOT EXISTS course_progress_user_idx ON public.course_progress(user_id);
CREATE INDEX IF NOT EXISTS course_progress_course_idx ON public.course_progress(course_id);

-- =====================================================
-- STEP 7: Create the placement_progress table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.placement_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  status TEXT CHECK (status IN ('not_started','in_progress','submitted','approved','rejected')) NOT NULL DEFAULT 'not_started',
  started_at TIMESTAMPTZ,
  submitted_at TIMESTAMPTZ,
  decided_at TIMESTAMPTZ,
  decided_by UUID,
  score NUMERIC(5,2),
  notes TEXT
);

CREATE INDEX IF NOT EXISTS placement_progress_user_idx ON public.placement_progress(user_id);
CREATE INDEX IF NOT EXISTS placement_progress_status_idx ON public.placement_progress(status);

-- =====================================================
-- STEP 8: Create the admin_approvals table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.admin_approvals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  admin_id UUID NOT NULL,
  user_id UUID NOT NULL,
  resource_kind TEXT NOT NULL CHECK (resource_kind IN ('exam','placement')),
  resource_id TEXT NOT NULL,
  action TEXT NOT NULL CHECK (action IN ('approved','rejected')),
  reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS admin_approvals_user_idx ON public.admin_approvals(user_id);
CREATE INDEX IF NOT EXISTS admin_approvals_admin_idx ON public.admin_approvals(admin_id);

-- =====================================================
-- STEP 9: Enable Row Level Security
-- =====================================================
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.course_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.placement_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_approvals ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- STEP 10: Create RLS Policies
-- =====================================================

-- Profiles policies
CREATE POLICY "profile_self_read" ON public.profiles 
  FOR SELECT USING (auth.uid() IS NOT NULL);

CREATE POLICY "profile_self_update" ON public.profiles 
  FOR UPDATE USING (auth.uid() IS NOT NULL);

CREATE POLICY "profile_self_insert" ON public.profiles 
  FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

-- Wallets policies
CREATE POLICY "wallets_self_all" ON public.wallets 
  FOR ALL USING (auth.uid() IS NOT NULL) 
  WITH CHECK (auth.uid() IS NOT NULL);

-- Sessions policies
CREATE POLICY "sessions_self_read" ON public.sessions 
  FOR SELECT USING (auth.uid() IS NOT NULL);

CREATE POLICY "sessions_self_insert" ON public.sessions 
  FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

CREATE POLICY "sessions_self_update" ON public.sessions 
  FOR UPDATE USING (auth.uid() IS NOT NULL);

-- Event log policies
CREATE POLICY "events_self_read" ON public.event_log 
  FOR SELECT USING (auth.uid() IS NOT NULL);

CREATE POLICY "events_self_insert" ON public.event_log 
  FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

-- Course progress policies
CREATE POLICY "course_prog_self_read" ON public.course_progress 
  FOR SELECT USING (auth.uid() IS NOT NULL);

CREATE POLICY "course_prog_self_insert" ON public.course_progress 
  FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);

CREATE POLICY "course_prog_self_update" ON public.course_progress 
  FOR UPDATE USING (auth.uid() IS NOT NULL);

-- Placement progress policies
CREATE POLICY "placement_prog_self_read" ON public.placement_progress 
  FOR SELECT USING (auth.uid() IS NOT NULL);

-- Admin approvals policies
CREATE POLICY "admin_approvals_self_read" ON public.admin_approvals 
  FOR SELECT USING (auth.uid() IS NOT NULL);

-- =====================================================
-- STEP 11: Create Helper Views
-- =====================================================

-- Inactive users (no events in last 7 days)
CREATE OR REPLACE VIEW public.inactive_users_7d AS
SELECT 
  p.id as user_id, 
  p.primary_wallet, 
  p.display_name,
  p.last_active_at,
  COALESCE(p.last_active_at, p.created_at) as last_event_at
FROM public.profiles p
WHERE p.last_active_at IS NULL OR p.last_active_at < NOW() - INTERVAL '7 days';

-- Live users (active in last 5 minutes)
CREATE OR REPLACE VIEW public.live_users AS
SELECT 
  s.user_id,
  s.wallet_address,
  p.display_name,
  s.last_heartbeat_at,
  s.started_at,
  EXTRACT(EPOCH FROM (NOW() - s.last_heartbeat_at))/60 as minutes_since_last_heartbeat
FROM public.sessions s
LEFT JOIN public.profiles p ON p.id = s.user_id
WHERE s.is_active = true 
  AND s.last_heartbeat_at > NOW() - INTERVAL '5 minutes'
ORDER BY s.last_heartbeat_at DESC;

-- Top courses by active users (7 days)
CREATE OR REPLACE VIEW public.top_courses_7d AS
SELECT 
  course_id,
  COUNT(DISTINCT user_id) as active_users,
  COUNT(*) as total_events,
  MIN(created_at) as first_activity,
  MAX(created_at) as last_activity
FROM public.event_log
WHERE course_id IS NOT NULL 
  AND created_at > NOW() - INTERVAL '7 days'
  AND kind IN ('course_start', 'lesson_start', 'lesson_complete', 'course_complete')
GROUP BY course_id
ORDER BY active_users DESC;

-- =====================================================
-- STEP 12: Create Utility Functions
-- =====================================================

-- Function to get user stats
CREATE OR REPLACE FUNCTION public.get_user_stats(target_user_id UUID DEFAULT NULL)
RETURNS TABLE (
  total_events BIGINT,
  unique_sessions BIGINT,
  first_activity TIMESTAMPTZ,
  last_activity TIMESTAMPTZ,
  courses_started BIGINT,
  courses_completed BIGINT,
  total_page_views BIGINT
) LANGUAGE plpgsql AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(el.*) as total_events,
    COUNT(DISTINCT el.session_id) as unique_sessions,
    MIN(el.created_at) as first_activity,
    MAX(el.created_at) as last_activity,
    COUNT(CASE WHEN el.kind = 'course_start' THEN 1 END) as courses_started,
    COUNT(CASE WHEN el.kind = 'course_complete' THEN 1 END) as courses_completed,
    COUNT(CASE WHEN el.kind = 'page_view' THEN 1 END) as total_page_views
  FROM public.event_log el
  WHERE el.user_id = COALESCE(target_user_id, auth.uid())
  GROUP BY el.user_id;
END $$;

-- Function to end stale sessions
CREATE OR REPLACE FUNCTION public.end_stale_sessions()
RETURNS INTEGER LANGUAGE plpgsql AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE public.sessions 
  SET is_active = false, ended_at = NOW()
  WHERE is_active = true 
    AND last_heartbeat_at < NOW() - INTERVAL '1 hour';
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END $$;

-- =====================================================
-- STEP 13: Grant Permissions
-- =====================================================
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
GRANT SELECT ON public.inactive_users_7d TO authenticated;
GRANT SELECT ON public.live_users TO authenticated;
GRANT SELECT ON public.top_courses_7d TO authenticated;
