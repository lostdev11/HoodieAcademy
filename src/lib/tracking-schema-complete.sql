-- =====================================================
-- COMPREHENSIVE TRACKING SCHEMA FOR HOODIE ACADEMY
-- =====================================================
-- This schema extends the existing users table with comprehensive tracking
-- Run this in your Supabase SQL Editor

-- =====================================================
-- 1. CREATE ENUMS
-- =====================================================

DO $$ BEGIN
    CREATE TYPE public.event_kind AS ENUM (
      'wallet_connect',
      'wallet_disconnect',
      'page_view',
      'course_start',
      'course_complete',
      'lesson_start',
      'lesson_complete',
      'exam_started',
      'exam_submitted',
      'exam_approved',
      'exam_rejected',
      'placement_started',
      'placement_completed',
      'custom'
    );
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE public.bounty_status AS ENUM ('draft','open','closed');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE public.submission_status AS ENUM ('pending_review','approved','rejected','needs_revision');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE public.xp_source AS ENUM ('bounty_submission','admin_adjustment','course','other');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- =====================================================
-- 2. EXTEND EXISTING USERS TABLE
-- =====================================================

-- Add tracking columns to existing users table if they don't exist
DO $$ BEGIN
    ALTER TABLE public.users ADD COLUMN IF NOT EXISTS primary_wallet TEXT;
    ALTER TABLE public.users ADD COLUMN IF NOT EXISTS last_active_at TIMESTAMPTZ;
    ALTER TABLE public.users ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();
EXCEPTION
    WHEN duplicate_column THEN null;
END $$;

-- Create indexes for new columns
CREATE INDEX IF NOT EXISTS users_primary_wallet_idx ON public.users(primary_wallet);
CREATE INDEX IF NOT EXISTS users_last_active_at_idx ON public.users(last_active_at);

-- =====================================================
-- 3. WALLETS TABLE (1:N per user)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.wallets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  address TEXT NOT NULL,
  label TEXT,
  is_primary BOOLEAN NOT NULL DEFAULT false,
  connected_first_at TIMESTAMPTZ,
  connected_last_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX IF NOT EXISTS wallets_user_address_uniq ON public.wallets(user_id, address);
CREATE INDEX IF NOT EXISTS wallets_primary_idx ON public.wallets(is_primary);
CREATE INDEX IF NOT EXISTS wallets_address_idx ON public.wallets(address);

-- =====================================================
-- 4. SESSIONS TABLE (heartbeats and session tracking)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  wallet_address TEXT,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_heartbeat_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  user_agent TEXT,
  ip INET
);

CREATE INDEX IF NOT EXISTS sessions_user_idx ON public.sessions(user_id);
CREATE INDEX IF NOT EXISTS sessions_heartbeat_idx ON public.sessions(last_heartbeat_at);
CREATE INDEX IF NOT EXISTS sessions_wallet_idx ON public.sessions(wallet_address);

-- =====================================================
-- 5. EVENT LOG (immutable append-only)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.event_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  session_id UUID REFERENCES public.sessions(id) ON DELETE SET NULL,
  wallet_address TEXT,
  kind public.event_kind NOT NULL,
  path TEXT, -- for page_view
  referrer TEXT,
  course_id TEXT,
  lesson_id TEXT,
  exam_id TEXT,
  payload JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS event_log_user_time_idx ON public.event_log(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS event_log_kind_time_idx ON public.event_log(kind, created_at DESC);
CREATE INDEX IF NOT EXISTS event_log_path_idx ON public.event_log(path);
CREATE INDEX IF NOT EXISTS event_log_session_idx ON public.event_log(session_id);

-- =====================================================
-- 6. COURSE PROGRESS (coarse state)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.course_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  course_id TEXT NOT NULL,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  last_event_at TIMESTAMPTZ,
  progress_percent NUMERIC(5,2) NOT NULL DEFAULT 0,
  UNIQUE (user_id, course_id)
);

CREATE INDEX IF NOT EXISTS course_progress_user_idx ON public.course_progress(user_id);
CREATE INDEX IF NOT EXISTS course_progress_course_idx ON public.course_progress(course_id);

-- =====================================================
-- 7. PLACEMENT PROGRESS (per user)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.placement_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  status TEXT CHECK (status IN ('not_started','in_progress','submitted','approved','rejected')) NOT NULL DEFAULT 'not_started',
  started_at TIMESTAMPTZ,
  submitted_at TIMESTAMPTZ,
  decided_at TIMESTAMPTZ,
  decided_by UUID REFERENCES public.users(id),
  score NUMERIC(5,2),
  notes TEXT
);

CREATE INDEX IF NOT EXISTS placement_progress_user_idx ON public.placement_progress(user_id);
CREATE INDEX IF NOT EXISTS placement_progress_status_idx ON public.placement_progress(status);

-- =====================================================
-- 8. ADMIN APPROVALS (audit for exam approvals)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.admin_approvals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  admin_id UUID NOT NULL REFERENCES public.users(id),
  user_id UUID NOT NULL REFERENCES public.users(id),
  resource_kind TEXT NOT NULL CHECK (resource_kind IN ('exam','placement')),
  resource_id TEXT NOT NULL,
  action TEXT NOT NULL CHECK (action IN ('approved','rejected')),
  reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS admin_approvals_user_idx ON public.admin_approvals(user_id);
CREATE INDEX IF NOT EXISTS admin_approvals_admin_idx ON public.admin_approvals(admin_id);

-- =====================================================
-- 9. ADMIN WALLETS (for admin detection)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.admin_wallets (
  wallet_address TEXT PRIMARY KEY,
  label TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- 10. BOUNTIES TABLE
-- =====================================================

CREATE TABLE IF NOT EXISTS public.bounties (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug TEXT UNIQUE,
  title TEXT NOT NULL,
  description TEXT,
  reward_xp INTEGER NOT NULL DEFAULT 50,
  status public.bounty_status NOT NULL DEFAULT 'draft',
  created_by UUID REFERENCES public.users(id) ON DELETE SET NULL,
  open_at TIMESTAMPTZ,
  close_at TIMESTAMPTZ,
  tags JSONB NOT NULL DEFAULT '[]',
  max_submissions INTEGER,
  allow_multiple_submissions BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS bounties_status_idx ON public.bounties(status);
CREATE INDEX IF NOT EXISTS bounties_open_window_idx ON public.bounties(open_at, close_at);
CREATE INDEX IF NOT EXISTS bounties_created_by_idx ON public.bounties(created_by);

-- =====================================================
-- 11. BOUNTY SUBMISSIONS
-- =====================================================

CREATE TABLE IF NOT EXISTS public.bounty_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bounty_id UUID NOT NULL REFERENCES public.bounties(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  wallet_address TEXT,
  title TEXT,
  content TEXT,
  url TEXT,
  evidence_links JSONB NOT NULL DEFAULT '[]',
  status public.submission_status NOT NULL DEFAULT 'pending_review',
  score NUMERIC(5,2),
  reviewer_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
  reviewed_at TIMESTAMPTZ,
  feedback TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (bounty_id, user_id) -- one submission per user per bounty by default
);

CREATE INDEX IF NOT EXISTS bounty_submissions_bounty_idx ON public.bounty_submissions(bounty_id);
CREATE INDEX IF NOT EXISTS bounty_submissions_status_idx ON public.bounty_submissions(status);
CREATE INDEX IF NOT EXISTS bounty_submissions_user_idx ON public.bounty_submissions(user_id);

-- =====================================================
-- 12. XP EVENTS (append-only ledger)
-- =====================================================

CREATE TABLE IF NOT EXISTS public.xp_events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  source public.xp_source NOT NULL,
  source_id TEXT,
  delta INTEGER NOT NULL,
  reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS xp_events_user_time_idx ON public.xp_events(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS xp_events_source_idx ON public.xp_events(source);

-- =====================================================
-- 13. XP BALANCES (view)
-- =====================================================

CREATE OR REPLACE VIEW public.xp_balances AS
SELECT user_id, COALESCE(SUM(delta), 0) as total_xp
FROM public.xp_events
GROUP BY user_id;

-- =====================================================
-- 14. ACTIVITY DAILY (materialized view for DAU/WAU/MAU)
-- =====================================================

CREATE MATERIALIZED VIEW IF NOT EXISTS public.activity_daily AS
SELECT 
  DATE_TRUNC('day', created_at) as day, 
  COUNT(DISTINCT user_id) as dau
FROM public.event_log
WHERE kind IN ('page_view','lesson_start','lesson_complete','course_start','course_complete','exam_started','exam_submitted','placement_started','placement_completed','wallet_connect')
GROUP BY 1
WITH NO DATA;

CREATE UNIQUE INDEX IF NOT EXISTS activity_daily_day_idx ON public.activity_daily(day);

-- =====================================================
-- 15. INACTIVE USERS VIEW (no events in last 7 days)
-- =====================================================

CREATE OR REPLACE VIEW public.inactive_users_7d AS
SELECT 
  u.id as user_id, 
  u.wallet_address, 
  u.display_name,
  u.last_active_at
FROM public.users u
LEFT JOIN LATERAL (
  SELECT MAX(created_at) as last_evt
  FROM public.event_log e
  WHERE e.user_id = u.id
) le ON true
WHERE COALESCE(le.last_evt, u.created_at) < NOW() - INTERVAL '7 days';

-- =====================================================
-- 16. ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.course_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.placement_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_approvals ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bounties ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bounty_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.xp_events ENABLE ROW LEVEL SECURITY;

-- Helper function for admin detection
CREATE OR REPLACE FUNCTION public.is_admin() RETURNS BOOLEAN 
LANGUAGE plpgsql STABLE AS $$
DECLARE 
  w TEXT; 
BEGIN
  -- 1) JWT role claim
  IF (auth.jwt() ->> 'role') = 'admin' THEN 
    RETURN TRUE; 
  END IF;
  
  -- 2) Admin wallet table (compare to primary wallet in users table if present)
  BEGIN
    SELECT u.primary_wallet INTO w 
    FROM public.users u 
    WHERE u.id = auth.uid();
    
    IF EXISTS (
      SELECT 1 FROM public.admin_wallets a 
      WHERE a.wallet_address = w
    ) THEN 
      RETURN TRUE; 
    END IF;
  EXCEPTION 
    WHEN OTHERS THEN 
      RETURN FALSE; 
  END;
  
  RETURN FALSE;
END $$;

-- Wallets policies
CREATE POLICY IF NOT EXISTS "wallets self" ON public.wallets
  FOR ALL USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- Sessions policies
CREATE POLICY IF NOT EXISTS "sessions self read" ON public.sessions
  FOR SELECT USING (user_id = auth.uid());
CREATE POLICY IF NOT EXISTS "sessions self insert" ON public.sessions
  FOR INSERT WITH CHECK (user_id = auth.uid());

-- Event log policies
CREATE POLICY IF NOT EXISTS "events self read" ON public.event_log
  FOR SELECT USING (user_id = auth.uid());
CREATE POLICY IF NOT EXISTS "events self insert" ON public.event_log
  FOR INSERT WITH CHECK (user_id = auth.uid());

-- Course progress policies
CREATE POLICY IF NOT EXISTS "course prog self read" ON public.course_progress
  FOR SELECT USING (user_id = auth.uid());

-- Placement progress policies
CREATE POLICY IF NOT EXISTS "placement prog self read" ON public.placement_progress
  FOR SELECT USING (user_id = auth.uid());

-- Bounties policies
CREATE POLICY IF NOT EXISTS "bounties read open" ON public.bounties
  FOR SELECT USING (status IN ('open','draft') AND (public.is_admin() OR status='open'));
CREATE POLICY IF NOT EXISTS "bounties admin write" ON public.bounties
  FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- Submissions policies
CREATE POLICY IF NOT EXISTS "subs self read" ON public.bounty_submissions
  FOR SELECT USING (user_id = auth.uid() OR public.is_admin());
CREATE POLICY IF NOT EXISTS "subs self insert" ON public.bounty_submissions
  FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY IF NOT EXISTS "subs admin write" ON public.bounty_submissions
  FOR UPDATE USING (public.is_admin()) WITH CHECK (public.is_admin());

-- XP events policies
CREATE POLICY IF NOT EXISTS "xp self read" ON public.xp_events
  FOR SELECT USING (user_id = auth.uid() OR public.is_admin());
CREATE POLICY IF NOT EXISTS "xp admin insert" ON public.xp_events
  FOR INSERT WITH CHECK (public.is_admin());

-- Admin policies
CREATE POLICY IF NOT EXISTS "admin read all users" ON public.users
  FOR SELECT USING (public.is_admin());
CREATE POLICY IF NOT EXISTS "admin read all events" ON public.event_log
  FOR SELECT USING (public.is_admin());
CREATE POLICY IF NOT EXISTS "admin read all sessions" ON public.sessions
  FOR SELECT USING (public.is_admin());
CREATE POLICY IF NOT EXISTS "admin read all progress" ON public.course_progress
  FOR SELECT USING (public.is_admin());
CREATE POLICY IF NOT EXISTS "admin read all placement" ON public.placement_progress
  FOR SELECT USING (public.is_admin());

-- =====================================================
-- 17. TRIGGERS AND FUNCTIONS
-- =====================================================

-- Updated_at trigger function
CREATE OR REPLACE FUNCTION public.touch_updated_at() 
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN 
  NEW.updated_at = NOW(); 
  RETURN NEW; 
END $$;

-- Apply updated_at triggers
CREATE TRIGGER IF NOT EXISTS users_touch 
  BEFORE UPDATE ON public.users
  FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

CREATE TRIGGER IF NOT EXISTS bounties_touch 
  BEFORE UPDATE ON public.bounties
  FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

CREATE TRIGGER IF NOT EXISTS bounty_sub_touch 
  BEFORE UPDATE ON public.bounty_submissions
  FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Keep users.last_active_at in sync with activity
CREATE OR REPLACE FUNCTION public.bump_last_active() 
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  UPDATE public.users 
  SET last_active_at = NOW() 
  WHERE id = NEW.user_id;
  RETURN NEW;
END $$;

CREATE TRIGGER IF NOT EXISTS event_log_bump 
  AFTER INSERT ON public.event_log
  FOR EACH ROW EXECUTE FUNCTION public.bump_last_active();

-- Auto-set is_primary invariant
CREATE OR REPLACE FUNCTION public.ensure_single_primary_wallet() 
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.is_primary THEN
    UPDATE public.wallets 
    SET is_primary = FALSE 
    WHERE user_id = NEW.user_id AND id <> NEW.id;
    
    UPDATE public.users 
    SET primary_wallet = NEW.address 
    WHERE id = NEW.user_id;
  END IF;
  RETURN NEW;
END $$;

CREATE TRIGGER IF NOT EXISTS wallets_primary 
  BEFORE INSERT OR UPDATE ON public.wallets
  FOR EACH ROW EXECUTE FUNCTION public.ensure_single_primary_wallet();

-- Is bounty open helper
CREATE OR REPLACE FUNCTION public.is_bounty_open(bid UUID) 
RETURNS BOOLEAN LANGUAGE sql STABLE AS $$
  SELECT b.status = 'open'
     AND (b.open_at IS NULL OR NOW() >= b.open_at)
     AND (b.close_at IS NULL OR NOW() < b.close_at)
  FROM public.bounties b 
  WHERE b.id = bid
$$;

-- Award XP on approval (SECURITY DEFINER so it can insert xp even under strict RLS)
CREATE OR REPLACE FUNCTION public.award_xp_on_approval() 
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  IF (TG_OP = 'UPDATE' AND NEW.status = 'approved' AND OLD.status <> 'approved') THEN
    INSERT INTO public.xp_events(user_id, source, source_id, delta, reason)
    SELECT 
      NEW.user_id, 
      'bounty_submission', 
      NEW.id::text, 
      b.reward_xp,
      'XP for approved submission to bounty ' || COALESCE(b.title, b.id::text)
    FROM public.bounties b 
    WHERE b.id = NEW.bounty_id;
    
    -- also mark user as active
    UPDATE public.users 
    SET last_active_at = NOW() 
    WHERE id = NEW.user_id;
  END IF;
  RETURN NEW;
END $$;

CREATE TRIGGER IF NOT EXISTS bounty_sub_award 
  AFTER UPDATE ON public.bounty_submissions
  FOR EACH ROW EXECUTE FUNCTION public.award_xp_on_approval();

-- =====================================================
-- 18. GRANT PERMISSIONS
-- =====================================================

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO authenticated;

-- =====================================================
-- 19. SEED DATA (optional)
-- =====================================================

-- Insert some sample admin wallets (replace with your actual admin wallets)
INSERT INTO public.admin_wallets (wallet_address, label) VALUES 
  ('YOUR_ADMIN_WALLET_1', 'Primary Admin'),
  ('YOUR_ADMIN_WALLET_2', 'Secondary Admin')
ON CONFLICT (wallet_address) DO NOTHING;

-- =====================================================
-- 20. REFRESH MATERIALIZED VIEW
-- =====================================================

-- Refresh the materialized view with existing data
REFRESH MATERIALIZED VIEW public.activity_daily;
