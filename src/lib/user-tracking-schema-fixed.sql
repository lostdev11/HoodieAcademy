-- Comprehensive User Tracking Schema for Hoodie Academy (Fixed Version)
-- This creates all tables, indexes, RLS policies, and triggers for wallet-based user tracking

-- =====================================================
-- 1. PROFILES TABLE (extends auth.users)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  handle TEXT UNIQUE,
  display_name TEXT,
  avatar_url TEXT,
  primary_wallet TEXT, -- base58 wallet address
  last_active_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS profiles_primary_wallet_idx ON public.profiles(primary_wallet);
CREATE INDEX IF NOT EXISTS profiles_last_active_idx ON public.profiles(last_active_at);

-- =====================================================
-- 2. WALLETS TABLE (1:N per user)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.wallets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  address TEXT NOT NULL,
  label TEXT,
  is_primary BOOLEAN NOT NULL DEFAULT false,
  connected_first_at TIMESTAMPTZ,
  connected_last_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX IF NOT EXISTS wallets_user_address_uniq ON public.wallets(user_id, address);
CREATE INDEX IF NOT EXISTS wallets_primary_idx ON public.wallets(is_primary);
CREATE INDEX IF NOT EXISTS wallets_address_idx ON public.wallets(address);

-- =====================================================
-- 3. SESSIONS TABLE (heartbeats and session tracking)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  wallet_address TEXT,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_heartbeat_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  user_agent TEXT,
  ip INET,
  is_active BOOLEAN DEFAULT true
);

CREATE INDEX IF NOT EXISTS sessions_user_idx ON public.sessions(user_id);
CREATE INDEX IF NOT EXISTS sessions_heartbeat_idx ON public.sessions(last_heartbeat_at);
CREATE INDEX IF NOT EXISTS sessions_active_idx ON public.sessions(is_active);

-- =====================================================
-- 4. EVENT LOG TABLE (immutable append-only)
-- =====================================================
-- Create enum type safely
DO $$ BEGIN
    CREATE TYPE public.event_kind AS ENUM (
      'wallet_connect',
      'wallet_disconnect',
      'page_view',
      'course_start',
      'course_complete',
      'lesson_start',
      'lesson_complete',
      'exam_started',
      'exam_submitted',
      'exam_approved',
      'exam_rejected',
      'placement_started',
      'placement_completed',
      'custom'
    );
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

CREATE TABLE IF NOT EXISTS public.event_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  session_id UUID REFERENCES public.sessions(id) ON DELETE SET NULL,
  wallet_address TEXT,
  kind public.event_kind NOT NULL,
  path TEXT, -- for page_view
  referrer TEXT,
  course_id TEXT,
  lesson_id TEXT,
  exam_id TEXT,
  payload JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS event_log_user_time_idx ON public.event_log(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS event_log_kind_time_idx ON public.event_log(kind, created_at DESC);
CREATE INDEX IF NOT EXISTS event_log_path_idx ON public.event_log(path);
CREATE INDEX IF NOT EXISTS event_log_session_idx ON public.event_log(session_id);
CREATE INDEX IF NOT EXISTS event_log_wallet_idx ON public.event_log(wallet_address);

-- =====================================================
-- 5. COURSE PROGRESS TABLE (coarse state)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.course_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  course_id TEXT NOT NULL,
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  last_event_at TIMESTAMPTZ,
  progress_percent NUMERIC(5,2) NOT NULL DEFAULT 0,
  UNIQUE (user_id, course_id)
);

CREATE INDEX IF NOT EXISTS course_progress_user_idx ON public.course_progress(user_id);
CREATE INDEX IF NOT EXISTS course_progress_course_idx ON public.course_progress(course_id);

-- =====================================================
-- 6. PLACEMENT PROGRESS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS public.placement_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  status TEXT CHECK (status IN ('not_started','in_progress','submitted','approved','rejected')) NOT NULL DEFAULT 'not_started',
  started_at TIMESTAMPTZ,
  submitted_at TIMESTAMPTZ,
  decided_at TIMESTAMPTZ,
  decided_by UUID REFERENCES auth.users(id),
  score NUMERIC(5,2),
  notes TEXT
);

CREATE INDEX IF NOT EXISTS placement_progress_user_idx ON public.placement_progress(user_id);
CREATE INDEX IF NOT EXISTS placement_progress_status_idx ON public.placement_progress(status);

-- =====================================================
-- 7. ADMIN APPROVALS TABLE (audit for exam approvals)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.admin_approvals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  admin_id UUID NOT NULL REFERENCES auth.users(id),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  resource_kind TEXT NOT NULL CHECK (resource_kind IN ('exam','placement')),
  resource_id TEXT NOT NULL,
  action TEXT NOT NULL CHECK (action IN ('approved','rejected')),
  reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS admin_approvals_user_idx ON public.admin_approvals(user_id);
CREATE INDEX IF NOT EXISTS admin_approvals_admin_idx ON public.admin_approvals(admin_id);

-- =====================================================
-- 8. ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.course_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.placement_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_approvals ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "profile_self_read" ON public.profiles;
DROP POLICY IF EXISTS "profile_self_update" ON public.profiles;
DROP POLICY IF EXISTS "profile_self_insert" ON public.profiles;
DROP POLICY IF EXISTS "wallets_self_all" ON public.wallets;
DROP POLICY IF EXISTS "sessions_self_read" ON public.sessions;
DROP POLICY IF EXISTS "sessions_self_insert" ON public.sessions;
DROP POLICY IF EXISTS "sessions_self_update" ON public.sessions;
DROP POLICY IF EXISTS "events_self_read" ON public.event_log;
DROP POLICY IF EXISTS "events_self_insert" ON public.event_log;
DROP POLICY IF EXISTS "course_prog_self_read" ON public.course_progress;
DROP POLICY IF EXISTS "course_prog_self_insert" ON public.course_progress;
DROP POLICY IF EXISTS "course_prog_self_update" ON public.course_progress;
DROP POLICY IF EXISTS "placement_prog_self_read" ON public.placement_progress;
DROP POLICY IF EXISTS "admin_approvals_self_read" ON public.admin_approvals;

-- Profiles policies
CREATE POLICY "profile_self_read" ON public.profiles 
  FOR SELECT USING (id = auth.uid());

CREATE POLICY "profile_self_update" ON public.profiles 
  FOR UPDATE USING (id = auth.uid());

CREATE POLICY "profile_self_insert" ON public.profiles 
  FOR INSERT WITH CHECK (id = auth.uid());

-- Wallets policies
CREATE POLICY "wallets_self_all" ON public.wallets 
  FOR ALL USING (user_id = auth.uid()) 
  WITH CHECK (user_id = auth.uid());

-- Sessions policies
CREATE POLICY "sessions_self_read" ON public.sessions 
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "sessions_self_insert" ON public.sessions 
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "sessions_self_update" ON public.sessions 
  FOR UPDATE USING (user_id = auth.uid());

-- Event log policies
CREATE POLICY "events_self_read" ON public.event_log 
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "events_self_insert" ON public.event_log 
  FOR INSERT WITH CHECK (user_id = auth.uid());

-- Course progress policies
CREATE POLICY "course_prog_self_read" ON public.course_progress 
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "course_prog_self_insert" ON public.course_progress 
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "course_prog_self_update" ON public.course_progress 
  FOR UPDATE USING (user_id = auth.uid());

-- Placement progress policies
CREATE POLICY "placement_prog_self_read" ON public.placement_progress 
  FOR SELECT USING (user_id = auth.uid());

-- Admin approvals policies
CREATE POLICY "admin_approvals_self_read" ON public.admin_approvals 
  FOR SELECT USING (user_id = auth.uid() OR admin_id = auth.uid());

-- =====================================================
-- 9. TRIGGERS AND FUNCTIONS
-- =====================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.touch_updated_at() 
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN 
  NEW.updated_at = NOW(); 
  RETURN NEW; 
END $$;

-- Drop existing triggers if they exist
DROP TRIGGER IF EXISTS profiles_touch ON public.profiles;
DROP TRIGGER IF EXISTS event_log_bump ON public.event_log;
DROP TRIGGER IF EXISTS wallets_primary ON public.wallets;
DROP TRIGGER IF EXISTS update_wallet_timestamps ON public.event_log;

-- Trigger for profiles updated_at
CREATE TRIGGER profiles_touch 
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Function to bump last_active_at when events are logged
CREATE OR REPLACE FUNCTION public.bump_last_active() 
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  UPDATE public.profiles 
  SET last_active_at = NOW() 
  WHERE id = NEW.user_id;
  RETURN NEW;
END $$;

-- Trigger to update last_active_at on event_log insert
CREATE TRIGGER event_log_bump 
  AFTER INSERT ON public.event_log
  FOR EACH ROW EXECUTE FUNCTION public.bump_last_active();

-- Function to ensure single primary wallet per user
CREATE OR REPLACE FUNCTION public.ensure_single_primary_wallet() 
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.is_primary THEN
    -- Unset all other primary wallets for this user
    UPDATE public.wallets 
    SET is_primary = false 
    WHERE user_id = NEW.user_id AND id <> NEW.id;
    
    -- Update the profile's primary_wallet
    UPDATE public.profiles 
    SET primary_wallet = NEW.address 
    WHERE id = NEW.user_id;
  END IF;
  RETURN NEW;
END $$;

-- Trigger for wallets primary wallet management
CREATE TRIGGER wallets_primary 
  BEFORE INSERT OR UPDATE ON public.wallets
  FOR EACH ROW EXECUTE FUNCTION public.ensure_single_primary_wallet();

-- Function to update wallet connection timestamps
CREATE OR REPLACE FUNCTION public.update_wallet_timestamps() 
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  -- Update connected_last_at for wallet events
  IF NEW.kind IN ('wallet_connect', 'wallet_disconnect') AND NEW.wallet_address IS NOT NULL THEN
    UPDATE public.wallets 
    SET connected_last_at = NOW() 
    WHERE address = NEW.wallet_address;
    
    -- Set connected_first_at if this is the first connection
    UPDATE public.wallets 
    SET connected_first_at = COALESCE(connected_first_at, NOW()) 
    WHERE address = NEW.wallet_address AND connected_first_at IS NULL;
  END IF;
  
  RETURN NEW;
END $$;

-- Trigger to update wallet timestamps
CREATE TRIGGER update_wallet_timestamps 
  AFTER INSERT ON public.event_log
  FOR EACH ROW EXECUTE FUNCTION public.update_wallet_timestamps();

-- =====================================================
-- 10. UTILITY FUNCTIONS
-- =====================================================

-- Function to get user stats
CREATE OR REPLACE FUNCTION public.get_user_stats(target_user_id UUID DEFAULT NULL)
RETURNS TABLE (
  total_events BIGINT,
  unique_sessions BIGINT,
  first_activity TIMESTAMPTZ,
  last_activity TIMESTAMPTZ,
  courses_started BIGINT,
  courses_completed BIGINT,
  total_page_views BIGINT
) LANGUAGE plpgsql AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(el.*) as total_events,
    COUNT(DISTINCT el.session_id) as unique_sessions,
    MIN(el.created_at) as first_activity,
    MAX(el.created_at) as last_activity,
    COUNT(CASE WHEN el.kind = 'course_start' THEN 1 END) as courses_started,
    COUNT(CASE WHEN el.kind = 'course_complete' THEN 1 END) as courses_completed,
    COUNT(CASE WHEN el.kind = 'page_view' THEN 1 END) as total_page_views
  FROM public.event_log el
  WHERE el.user_id = COALESCE(target_user_id, auth.uid())
  GROUP BY el.user_id;
END $$;

-- Function to end stale sessions
CREATE OR REPLACE FUNCTION public.end_stale_sessions()
RETURNS INTEGER LANGUAGE plpgsql AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE public.sessions 
  SET is_active = false, ended_at = NOW()
  WHERE is_active = true 
    AND last_heartbeat_at < NOW() - INTERVAL '1 hour';
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END $$;

-- =====================================================
-- 11. HELPER VIEWS
-- =====================================================

-- Inactive users (no events in last 7 days)
CREATE OR REPLACE VIEW public.inactive_users_7d AS
SELECT 
  p.id as user_id, 
  p.primary_wallet, 
  p.display_name,
  p.last_active_at,
  COALESCE(le.last_evt, p.created_at) as last_event_at
FROM public.profiles p
LEFT JOIN LATERAL (
  SELECT MAX(created_at) as last_evt
  FROM public.event_log e
  WHERE e.user_id = p.id
) le ON true
WHERE COALESCE(le.last_evt, p.created_at) < NOW() - INTERVAL '7 days';

-- Live users (active in last 5 minutes)
CREATE OR REPLACE VIEW public.live_users AS
SELECT 
  s.user_id,
  s.wallet_address,
  p.display_name,
  s.last_heartbeat_at,
  s.started_at,
  EXTRACT(EPOCH FROM (NOW() - s.last_heartbeat_at))/60 as minutes_since_last_heartbeat
FROM public.sessions s
LEFT JOIN public.profiles p ON p.id = s.user_id
WHERE s.is_active = true 
  AND s.last_heartbeat_at > NOW() - INTERVAL '5 minutes'
ORDER BY s.last_heartbeat_at DESC;

-- Top courses by active users (7 days)
CREATE OR REPLACE VIEW public.top_courses_7d AS
SELECT 
  course_id,
  COUNT(DISTINCT user_id) as active_users,
  COUNT(*) as total_events,
  MIN(created_at) as first_activity,
  MAX(created_at) as last_activity
FROM public.event_log
WHERE course_id IS NOT NULL 
  AND created_at > NOW() - INTERVAL '7 days'
  AND kind IN ('course_start', 'lesson_start', 'lesson_complete', 'course_complete')
GROUP BY course_id
ORDER BY active_users DESC;

-- =====================================================
-- 12. GRANTS AND PERMISSIONS
-- =====================================================

-- Grant necessary permissions to authenticated users
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;

-- Grant select permissions on views
GRANT SELECT ON public.inactive_users_7d TO authenticated;
GRANT SELECT ON public.live_users TO authenticated;
GRANT SELECT ON public.top_courses_7d TO authenticated;

COMMENT ON TABLE public.profiles IS 'User profiles extending auth.users with wallet information';
COMMENT ON TABLE public.wallets IS 'Wallet addresses associated with users (1:N relationship)';
COMMENT ON TABLE public.sessions IS 'User sessions with heartbeat tracking for live user monitoring';
COMMENT ON TABLE public.event_log IS 'Immutable event log for all user activities and interactions';
COMMENT ON TABLE public.course_progress IS 'Course progress tracking with completion status';
COMMENT ON TABLE public.placement_progress IS 'Placement test progress and approval workflow';
COMMENT ON TABLE public.admin_approvals IS 'Audit log for admin actions on exams and placements';
